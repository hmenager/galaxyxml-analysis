<tool id="bowtie2" name="Bowtie2" version="2.3.2.2">
  <!--This tool descriptor has been annotated by ToolDog v0.3.1-->
  <description>- map reads against reference genome</description>
  <edam_operations>
    <edam_operation>operation_3198</edam_operation>
  </edam_operations>
  <edam_topics>
    <edam_topic>topic_0102</edam_topic>
  </edam_topics>
  <requirements>
    <requirement type="package" version="2.3.2">bowtie2</requirement>
    <requirement type="package" version="1.3.1">samtools</requirement>
  </requirements>
  <stdio>
    <exit_code level="fatal" range="1:"/>
  </stdio>
  <version_command>bowtie2 --version</version_command>
  <command><![CDATA[
        ## prepare bowtie2 index
        #set index_path = ''
        #if str($reference_genome.source) == "history":
            bowtie2-build --threads \${GALAXY_SLOTS:-4} '$reference_genome.own_file' genome &&
            ln -s -f '$reference_genome.own_file' genome.fa &&
            #set index_path = 'genome'
        #else:
            #set index_path = $reference_genome.index.fields.path
        #end if

        ## Link in the input files, so bowtie2 can tell their type

        #set compressed="False"
        #set reads_are_fastq = True
        #if str($library.type) == 'paired':
            #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read1 = "input_f.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read1 = "input_f.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_1.is_of_type('fasta'):
                #set reads_are_fastq = False
                #set read1 = "input_f.fasta"
            #else:
                #set read1 = "input_f.fastq"
            #end if
            ln -f -s '${library.input_1}' ${read1} &&

            #if $library.input_2.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read2 = "input_r.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_2.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read2 = "input_r.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_2.is_of_type('fasta'):
                #set read2 = "input_r.fasta"
            #else:
                #set read2 = "input_r.fastq"
            #end if
            ln -f -s '${library.input_2}' ${read2} &&
        #else if str($library.type) == 'paired_collection':
            #if $library.input_1.forward.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read1 = "input_f.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_1.forward.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read1 = "input_f.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_1.forward.is_of_type('fasta'):
                #set reads_are_fastq = False
                #set read1 = "input_f.fasta"
            #else:
                #set read1 = "input_f.fastq"
            #end if
            ln -s '${library.input_1.forward}' ${read1} &&

            #if $library.input_1.reverse.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read2 = "input_r.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_1.reverse.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read2 = "input_r.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_1.reverse.is_of_type("fasta"):
                #set read2 = "input_r.fasta"
            #else:
                #set read2 = "input_r.fastq"
            #end if
            ln -s '${library.input_1.reverse}' ${read2} &&

        #else if str($library.type) == 'paired_interleaved':
            #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read1 = "input_il.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read1 = "input_il.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_1.is_of_type("fasta"):
                #set reads_are_fastq = False
                #set read1 = "input_il.fasta"
            #else:
                #set read1 = "input_il.fastq"
            #end if
            ln -s '${library.input_1}' ${read1} &&
        #else:
            #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
                #set read1 = "input_f.fastq.gz"
                #set compressed = "GZ"
            #else if $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
                #set read1 = "input_f.fastq.bz2"
                #set compressed = "BZ2"
            #else if $library.input_1.is_of_type("fasta"):
                #set reads_are_fastq = False
                #set read1 = "input_f.fasta"
            #else:
                #set read1 = "input_f.fastq"
            #end if
            ln -s '${library.input_1}' ${read1} &&
        #end if

        ## execute bowtie2

        bowtie2

        ## number of threads
        -p \${GALAXY_SLOTS:-4}

        ## index file path
        -x '$index_path'

        ## Input reads are fasta?
        #if not reads_are_fastq:
            -f
        #end if

        ## Input reads
        #if str( $library.type ) == "single":
            -U '${read1}'
            #if str( $library.unaligned_file ) == "true":
                #if $compressed == "GZ":
                    --un-gz '${output_unaligned_reads_l}'
                #else if $compressed == "BZ2":
                    --un-bz2 '${output_unaligned_reads_l}'
                #else:
                    --un '${output_unaligned_reads_l}'
                #end if
            #end if
            #if str( $library.aligned_file ) == "true":
                #if $compressed == "GZ":
                    --al-gz '${output_aligned_reads_l}'
                #else if $compressed == "BZ2":
                    --al-bz2 '${output_aligned_reads_l}'
                #else:
                    --al '${output_aligned_reads_l}'
                #end if
            #end if

        #elif str( $library.type ) == "paired_interleaved":
            --interleaved '${read1}'
            #if str( $library.unaligned_file ) == "true":
                #if $compressed == "GZ":
                    --un-gz '${output_unaligned_reads_l}'
                #else if $compressed == "BZ2":
                    --un-bz2 '${output_unaligned_reads_l}'
                #else:
                    --un '${output_unaligned_reads_l}'
                #end if
            #end if
            #if str( $library.aligned_file ) == "true":
                #if $compressed == "GZ":
                    --al-gz '${output_aligned_reads_l}'
                #else if $compressed == "BZ2":
                    --al-bz2 '${output_aligned_reads_l}'
                #else:
                    --al '${output_aligned_reads_l}'
                #end if
            #end if
        #else:
            -1 '${read1}'
            -2 '${read2}'
            #if str( $library.unaligned_file ) == "true":
                #if $compressed == "GZ":
                    --un-conc-gz '${output_unaligned_reads_l}'
                #else if $compressed == "BZ2":
                    --un-conc-bz2 '${output_unaligned_reads_l}'
                #else:
                    --un-conc '${output_unaligned_reads_l}'
                #end if
            #end if
            #if str( $library.aligned_file ) == "true":
                #if $compressed == "GZ":
                    --al-conc-gz '${output_aligned_reads_l}'
                #else if $compressed == "BZ2":
                    --al-conc-bz2 '${output_aligned_reads_l}'
                #else:
                    --al-conc '${output_aligned_reads_l}'
                #end if
            #end if
            #if str( $library.paired_options.paired_options_selector ) == "yes":
                -I "${library.paired_options.I}"
                -X "${library.paired_options.X}"
                ${library.paired_options.fr_rf_ff}
                ${library.paired_options.no_mixed}
                ${library.paired_options.no_discordant}
                ${library.paired_options.dovetail}
                ${library.paired_options.no_contain}
                ${library.paired_options.no_overlap}
            #end if
        #end if

        ## Read group information.
        @define_read_group_helpers@
        #if str( $library.type ) == "single":
            #set $rg_auto_name = $read_group_name_default($library.input_1)
        #elif str( $library.type ) == "paired":
            #set $rg_auto_name = $read_group_name_default($library.input_1, $library.input_2)
        #else
            #set $rg_auto_name = $read_group_name_default($library.input_1)
        #end if
        @set_use_rg_var@
        @set_read_group_vars@
        #if $use_rg
          $format_read_group("", $rg_id, '"', arg='--rg-id ')
          $format_read_group("SM:", $rg_sm, '"', arg='--rg ')
          $format_read_group("PL:", $rg_pl, '"', arg='--rg ')
          $format_read_group("LB:", $rg_lb, '"', arg='--rg ')
          $format_read_group("CN:", $rg_cn, '"', arg='--rg ')
          $format_read_group("DS:", $rg_ds, '"', arg='--rg ')
          $format_read_group("DT:", $rg_dt, '"', arg='--rg ')
          $format_read_group("FO:", $rg_fo, '"', arg='--rg ')
          $format_read_group("KS:", $rg_ks, '"', arg='--rg ')
          $format_read_group("PG:", $rg_pg, '"', arg='--rg ')
          $format_read_group("PI:", $rg_pi, '"', arg='--rg ')
          $format_read_group("PU:", $rg_pu, '"', arg='--rg ')
        #end if

        ## Analysis type
        #if ( str( $analysis_type.analysis_type_selector ) == "simple" and str( $analysis_type.presets ) != "no_presets" ):
            $analysis_type.presets
        #elif str( $analysis_type.analysis_type_selector ) == "full":
            #if str( $analysis_type.input_options.input_options_selector ) == "yes":
                --skip "${analysis_type.input_options.skip}"
                --qupto "${analysis_type.input_options.qupto}"
                --trim5 "${analysis_type.input_options.trim5}"
                --trim3 "${analysis_type.input_options.trim3}"
                ${analysis_type.input_options.qv_encoding}
                ${analysis_type.input_options.solexa_quals}
                ${analysis_type.input_options.int_quals}
            #end if

            #if str( $analysis_type.alignment_options.alignment_options_selector ) == "yes":
                -N "${analysis_type.alignment_options.N}"
                -L "${analysis_type.alignment_options.L}"
                -i "${analysis_type.alignment_options.i}"
                --n-ceil "${analysis_type.alignment_options.n_ceil}"
                --dpad "${analysis_type.alignment_options.dpad}"
                --gbar "${analysis_type.alignment_options.gbar}"
                ${analysis_type.alignment_options.ignore_quals}
                ${analysis_type.alignment_options.nofw}
                ${analysis_type.alignment_options.norc}
                ${analysis_type.alignment_options.no_1mm_upfront}
                #if str( $analysis_type.alignment_options.align_mode.align_mode_selector ) == "end-to-end":
                    --end-to-end
                    --score-min "${analysis_type.alignment_options.align_mode.score_min_ete}"
                #elif str( $analysis_type.alignment_options.align_mode.align_mode_selector ) == "local":
                    --local
                    --score-min "${analysis_type.alignment_options.align_mode.score_min_loc}"
                #end if
            #end if

            #if str( $analysis_type.scoring_options.scoring_options_selector ) == "yes":
                #if ( str( $analysis_type.alignment_options.alignment_options_selector ) == "yes" and str( $analysis_type.alignment_options.align_mode.align_mode_selector ) == "local" ):
                    --ma "${analysis_type.scoring_options.ma}"
                #end if
                --mp "${analysis_type.scoring_options.mp}"
                --np "${analysis_type.scoring_options.np}"
                --rdg "${analysis_type.scoring_options.rdg_read_open},${analysis_type.scoring_options.rdg_read_extend}"
                --rfg "${analysis_type.scoring_options.rfg_ref_open},${analysis_type.scoring_options.rfg_ref_extend}"
            #end if

            #if str( $analysis_type.reporting_options.reporting_options_selector ) == "k":
                -k "${analysis_type.reporting_options.k}"
            #elif str( $analysis_type.reporting_options.reporting_options_selector ) == "a":
                -a
            #end if

            #if str( $analysis_type.effort_options.effort_options_selector ) == "yes":
                -D "${analysis_type.effort_options.D}"
                -R "${analysis_type.effort_options.R}"
            #end if

            #if str( $analysis_type.sam_options.sam_options_selector ) == "yes":
                ${analysis_type.sam_options.no_unal}
                ${analysis_type.sam_options.omit_sec_seq}
            #end if

            #if str( $analysis_type.other_options.other_options_selector ) == "yes":
                ${analysis_type.other_options.reorder}
                ${analysis_type.other_options.non_deterministic}
                --seed "${analysis_type.other_options.seed}"
            #end if

        #elif str( $analysis_type.analysis_type_selector ) == "cline":
            ${analysis_type.cline}
        #end if

        ## mapping stats (i.e. stderr from bowtie2)
        #if $save_mapping_stats
            2> '$mapping_stats'
        #end if

        ## output file
        #if ( str( $analysis_type.analysis_type_selector ) != "full" or str( $analysis_type.sam_opt ) != "true" ):
            | samtools sort -O bam -o '$output'
        #else
            > '$output_sam'
        #end if

        ## rename unaligned sequence files
        #if $library.type == "paired" and $output_unaligned_reads_l and $output_unaligned_reads_r:
            #from os.path import splitext
            #set _unaligned_root, _unaligned_ext = splitext( str( $output_unaligned_reads_l ) )
            && mv "${ _unaligned_root }.1${_unaligned_ext}" '$output_unaligned_reads_l'
            && mv "${ _unaligned_root }.2${_unaligned_ext}" '$output_unaligned_reads_r'
        #end if
        #if $library.type == "paired" and $output_aligned_reads_l and $output_aligned_reads_r:
            #from os.path import splitext
            #set _aligned_root, _aligned_ext = splitext( str( $output_aligned_reads_l ) )
            && mv "${ _aligned_root }.1${_aligned_ext}" '$output_aligned_reads_l'
            && mv "${ _aligned_root }.2${_aligned_ext}" '$output_aligned_reads_r'
        #end if

        ]]></command>
  <inputs>
    <conditional argument="library" label="Author did not provide help for this parameter... " name="library">
      <param argument="type" label="Is this single or paired library" name="type" type="select">
        <option value="single">Single-end</option>
        <option value="paired">Paired-end</option>
        <option value="paired_collection">Paired-end Dataset Collection</option>
        <option value="paired_interleaved">Paired-end data from single interleaved dataset</option>
      </param>
      <when value="single">
        <param argument="input_1" format="fastqsanger,fastqsanger.gz,fastqsanger.bz2,fasta" help="Must be of datatype &quot;fastqsanger&quot; or &quot;fasta&quot;" label="FASTA/Q file" name="input_1" type="data"/>
      </when>
      <when value="paired">
        <param argument="input_1" format="fastqsanger,fastqsanger.gz,fastqsanger.bz2,fasta" help="Must be of datatype &quot;fastqsanger&quot;or &quot;fasta&quot;" label="FASTA/Q file #1" name="input_1" type="data"/>
        <param argument="input_2" format="fastqsanger,fastqsanger.gz,fastqsanger.bz2,fasta" help="Must be of datatype &quot;fastqsanger&quot;or &quot;fasta&quot;" label="FASTA/Q file #2" name="input_2" type="data"/>
      </when>
      <when value="paired_collection"/>
      <when value="paired_interleaved">
        <param argument="input_1" format="fastqsanger,fastqsanger.gz,fastqsanger.bz2,fasta" help="Must be of datatype &quot;fastqsanger&quot; or &quot;fasta&quot;. --interleaved" label="Interleaved FASTQ file" name="input_1" type="data"/>
      </when>
    </conditional>
    <conditional argument="reference_genome" label="Author did not provide help for this parameter... " name="reference_genome">
      <param argument="source" help="Built-ins were indexed using default options. See `Indexes` section of help below" label="Will you select a reference genome from your history or use a built-in index?" name="source" type="select">
        <option value="indexed">Use a built-in genome index</option>
        <option value="history">Use a genome from the history and build index</option>
      </param>
      <when value="indexed">
        <param argument="index" help="If your genome of interest is not listed, contact the Galaxy team" label="Select reference genome" name="index" type="select">
          <options from_data_table="bowtie2_indexes">
            <filter column="2" type="sort_by"/>
          </options>
        </param>
      </when>
      <when value="history">
        <param argument="own_file" format="fasta" label="Select reference genome" name="own_file" type="data"/>
      </when>
    </conditional>
    <conditional argument="analysis_type" label="Author did not provide help for this parameter... " name="analysis_type">
      <param argument="analysis_type_selector" label="Select analysis mode" name="analysis_type_selector" type="select">
        <option value="simple">1: Default setting only</option>
        <option value="full">2: Full parameter list</option>
      </param>
      <when value="simple">
        <param argument="presets" display="radio" help="Allow selecting among several preset parameter settings. Choosing between these will result in dramatic changes in runtime. See help below to understand effects of these presets." label="Do you want to use presets?" name="presets" type="select">
          <option selected="true" value="no_presets">No, just use defaults</option>
          <option value="--very-fast">Very fast end-to-end (--very-fast)</option>
          <option value="--fast">Fast end-to-end (--fast)</option>
          <option value="--sensitive">Sensitive end-to-end (--sensitive)</option>
          <option value="--very-sensitive">Very sensitive end-to-end (--very-sensitive)</option>
          <option value="--very-fast-local">Very fast local (--very-fast-local)</option>
          <option value="--fast-local">Fast local (--fast-local)</option>
          <option value="--sensitive-local">Sensitive local (--sensitive-local)</option>
          <option value="--very-sensitive-local">Very sensitive local (--very-sensitive-local)</option>
        </param>
      </when>
      <when value="full">
        <conditional argument="input_options" label="Author did not provide help for this parameter... " name="input_options">
          <param argument="input_options_selector" help="See &quot;Input Options&quot; section of Help below for information" label="Do you want to tweak input options?" name="input_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="skip" help="-s/--skip; default=0" label="Skip (i.e. do not align) the first that many reads or pairs in the input" min="0" name="skip" type="integer" value="0"/>
            <param argument="qupto" help="-u/--qupto; for default behavior (no limit) leave this value very large" label="Align the first that many reads or read pairs from the input (after the -s/--skip reads or pairs have been skipped), then stop" min="1" name="qupto" type="integer" value="100000000"/>
            <param argument="trim5" help="-5/--trim5; default=0" label="Trim that many bases from 5' (left) end of each read before alignment" min="0" name="trim5" type="integer" value="0"/>
            <param argument="trim3" help="-3/--trim3; default=0" label="Trim that many bases from 3' (right) end of each read before alignment" min="0" name="trim3" type="integer" value="0"/>
            <param argument="qv_encoding" display="radio" help="See help below for more details" label="Select quality score encoding" name="qv_encoding" type="select">
              <option selected="true" value="--phred33">Input qualities are ASCII chars equal to the Phred quality plus 33. This is also called the "Phred+33" encoding, which is used by the very latest Illumina pipelines (--phred33)</option>
              <option value="--phred64">Input qualities are ASCII chars equal to the Phred quality plus 64. This is also called the "Phred+64" encoding (--phred64)</option>
            </param>
            <param argument="solexa_quals" checked="False" falsevalue="" help="--solexa-quals; default=False" label="Convert input qualities from Solexa (which can be negative) to Phred (which can't). This scheme was used in older Illumina GA Pipeline versions (prior to 1.3)" name="solexa_quals" truevalue="--solexa-quals" type="boolean"/>
            <param argument="int_quals" checked="False" falsevalue="" help="--int-quals; default=False" label="Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I.... Integers are treated as being on the Phred quality scale unless --solexa-quals is also specified" name="int_quals" truevalue="--int-quals" type="boolean"/>
          </when>
          <when value="no"/>
        </conditional>
        <conditional argument="alignment_options" label="Author did not provide help for this parameter... " name="alignment_options">
          <param argument="alignment_options_selector" help="See &quot;Alignment Options&quot; section of Help below for information" label="Do you want to tweak alignment options?" name="alignment_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="N" help="-N; Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity; default=0" label="Set the number of mismatches to be allowed in a seed alignment during multiseed alignment (see `Multiseed alignment` section of help below)" max="1" min="0" name="N" type="integer" value="0"/>
            <param argument="L" help="-L; Smaller values make alignment slower but more sensitive. Default=22" label="Sets the length of the seed substrings to align during multiseed alignment (see `Multiseed alignment` section of help below)" max="32" min="0" name="L" type="integer" value="22"/>
            <param area="false" argument="i" help="-i; Since it's best to use longer intervals for longer reads, this parameter sets the interval as a function of the read length, rather than a single one-size-fits-all number. For instance, specifying `-i S,1,2.5` sets the interval function `f` to `f(x) = 1 + 2.5 * sqrt(x)`, where x is the read length. If the function returns a result less than 1, it is rounded up to 1. Default=`S,1,1.15`" label="Set a function governing the interval between seed substrings to use during multiseed alignment (see `Multiseed alignment` section of help below). Also see description of this option below in the help section" name="i" type="text" value="S,1,1.15"/>
            <param area="false" argument="n_ceil" help="--n-ceil; For instance, specifying `L,0,0.15` sets the N-ceiling function `f` to `f(x) = 0 + 0.15 * x`, where x is the read length. Reads exceeding this ceiling are filtered out. Default=`L,0,0.15`" label="Set a function governing the maximum number of ambiguous characters (usually `N`s and/or `.`s) allowed in a read as a function of read length" name="n_ceil" type="text" value="L,0,0.15"/>
            <param argument="dpad" help="--dpad; default=15" label="Pad dynamic programming problems by that many columns on either side to allow gaps" min="0" name="dpad" type="integer" value="15"/>
            <param argument="gbar" help="--gbar; default=4" label="Disallow gaps within that many positions of the beginning or end of the read" min="0" name="gbar" type="integer" value="4"/>
            <param argument="ignore_quals" checked="false" falsevalue="" help="--ignore-quals; input is treated as though all quality values are high; default=False" label="When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value" name="ignore_quals" truevalue="--ignore-quals" type="boolean"/>
            <param argument="nofw" checked="false" falsevalue="" help="In paired-end mode, `--nofw` and `--norc` pertain to the fragments; i.e. specifying `--nofw` causes `bowtie2` to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default=False" label="Do not attempt to align unpaired reads to the forward (Watson) reference strand" name="nofw" truevalue="--nofw" type="boolean"/>
            <param argument="norc" checked="false" falsevalue="" help="In paired-end mode, `--nofw` and `--norc` pertain to the fragments; i.e. specifying `--nofw` causes `bowtie2` to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default=False" label="Do not attempt to align unpaired reads to the reverse (Crick) reference strand" name="norc" truevalue="--norc" type="boolean"/>
            <param argument="no_1mm_upfront" checked="false" falsevalue="" help="--no-1mm-upfront; By default, Bowtie 2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read *before* trying the multiseed heuristic.  Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments.  However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like `-L` and `-N`.  For instance, if the user specifies `-N 0` and `-L` equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported.  This option prevents Bowtie 2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as `-L` and `-N`. This comes at the expense of speed; Default=False" label="Prevent searching for 1-mismatch end-to-end alignments before using the multiseed heuristic (see `Multiseed alignment` section of help below)" name="no_1mm_upfront" truevalue="--no-1mm-upfront" type="boolean"/>
            <conditional argument="align_mode" label="Author did not provide help for this parameter... " name="align_mode">
              <param argument="align_mode_selector" display="radio" help="--local and --end-to-end; see help below for detailed explanation; default=--end-to-end" label="Select between `--local` and `--end-to-end` alignment modes" name="align_mode_selector" type="select">
                <option selected="true" value="end-to-end">End to End (--end-to-end)</option>
                <option value="local">Local (--local)</option>
              </param>
              <when value="end-to-end">
                <param area="false" argument="score_min_ete" help="--score-min; This is a function of read length. For instance, specifying `L,0,-0.6` sets the minimum-score function `f` to `f(x) = 0 + -0.6 * x`, where `x` is the read length. The default in `--end-to-end` mode is `L,-0.6,-0.6` and the default in `--local` mode is `G,20,8`" label="Set a function governing the minimum alignment score needed for an alignment to be considered `valid` (i.e. good enough to report)" name="score_min_ete" type="text" value="L,-0.6,-0.6"/>
              </when>
              <when value="local">
                <param area="false" argument="score_min_loc" help="--score-min; This is a function of read length. For instance, specifying `L,0,-0.6` sets the minimum-score function `f` to `f(x) = 0 + -0.6 * x`, where `x` is the read length. The default in `--end-to-end` mode is `L,-0.6,-0.6` and the default in `--local` mode is `G,20,8`" label="Set a function governing the minimum alignment score needed for an alignment to be considered `valid` (i.e. good enough to report)" name="score_min_loc" type="text" value="G,20,8"/>
              </when>
            </conditional>
          </when>
          <when value="no"/>
        </conditional>
        <conditional argument="scoring_options" label="Author did not provide help for this parameter... " name="scoring_options">
          <param argument="scoring_options_selector" help="See &quot;Scoring Options&quot; section of Help below for information" label="Do you want to tweak scoring options?" name="scoring_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="ma" help="--ma;  In `--local` mode match bonus is added to the alignment score for each position where a read character aligns to a reference character and the characters match. Not used in `--end-to-end` mode; Default=2" label="Set the match bonus" name="ma" type="integer" value="2"/>
            <param area="false" argument="mp" help="--mp; A number less than or equal to `MX` and greater than or equal to `MN` is subtracted from the alignment score for each position where a read character aligns to a reference character, the characters do not match, and neither is an `N`.  If `--ignore-quals` is specified, the number subtracted quals `MX`. Otherwise, the number subtracted is `MN + floor( (MX-MN)(MIN(Q, 40.0)/40.0) )` where Q is the Phred quality value; Default=6,2" label="Set the maximum (`MX`) and minimum (`MN`) mismatch penalties, both integers" name="mp" type="text" value="6,2"/>
            <param argument="np" help="--np; Default=1" label="Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as `N`" name="np" type="integer" value="1"/>
            <param argument="rdg_read_open" help="--rdg; this is the first component of --rdg flag - opening penalty; Default=5" label="Set the read gap opening penalty" name="rdg_read_open" type="integer" value="5"/>
            <param argument="rdg_read_extend" help="--rdg; this is the second component of --rdg flag - extension penalty; Default=3" label="Set the read gap extension penalty" name="rdg_read_extend" type="integer" value="3"/>
            <param argument="rfg_ref_open" help="--rfg; this is the first component of --rfg flag - opening penalty; Default=5" label="Set the reference gap opening penalty" name="rfg_ref_open" type="integer" value="5"/>
            <param argument="rfg_ref_extend" help="--rfg; this is the second component of --rfg flag - extension penalty; Default=3" label="Set the reference gap extension penalty" name="rfg_ref_extend" type="integer" value="3"/>
          </when>
          <when value="no"/>
        </conditional>
        <conditional argument="reporting_options" label="Author did not provide help for this parameter... " name="reporting_options">
          <param argument="reporting_options_selector" help="Make sure you understand implications of setting -k and -a. See &quot;Reporting Options&quot; section of Help below for information on -k and -a options" label="Do you want to use -a or -k options" name="reporting_options_selector" type="select">
            <option selected="true" value="no">No, do not set</option>
            <option value="k">Set -k option and enter -k value</option>
            <option value="a">Set -a option</option>
          </param>
          <when value="no"/>
          <when value="k">
            <param argument="k" help="-k; see detailed description of this option in the help section below. Note: Bowtie 2 is not designed with large values for `-k` in mind, and when aligning reads to long, repetitive genomes large `-k` can be very, very slow" label="Searches for at most that many distinct, valid alignments for each read" min="1" name="k" type="integer" value="1"/>
          </when>
          <when value="a"/>
        </conditional>
        <conditional argument="effort_options" label="Author did not provide help for this parameter... " name="effort_options">
          <param argument="effort_options_selector" help="See &quot;Effort Options&quot; section of Help below for information" label="Do you want to tweak effort options?" name="effort_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="D" help="-D; A seed extension `fails` if it does not yield a new best or a new second-best alignment.  This limit is automatically adjusted up when -k or -a are specified. Default=15" label="Attempt that many consecutive seed extension attempts to `fail` before Bowtie 2 moves on, using the alignments found so far" min="0" name="D" type="integer" value="15"/>
            <param argument="R" help="When `re-seeding`, Bowtie 2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments.  A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.  Default=2" label="Set the maximum number of times Bowtie 2 will `re-seed` reads with repetitive seeds" min="0" name="R" type="integer" value="2"/>
          </when>
          <when value="no"/>
        </conditional>
        <conditional argument="sam_options" label="Author did not provide help for this parameter... " name="sam_options">
          <param argument="sam_options_selector" help="See &quot;Output Options&quot; section of Help below for information" label="Do you want to tweak SAM/BAM Options?" name="sam_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="no_unal" checked="false" falsevalue="" help="--no-unal; Default=False" label="Suppress SAM records for reads that failed to align" name="no_unal" truevalue="--no-unal" type="boolean"/>
            <param argument="omit_sec_seq" checked="false" falsevalue="" help="--omit-sec-seq; Default=False" label="Suppress SEQ and QUAL strings for secondary alignments" name="omit_sec_seq" truevalue="--omit-sec-seq" type="boolean"/>
          </when>
          <when value="no"/>
        </conditional>
        <conditional argument="other_options" label="Author did not provide help for this parameter... " name="other_options">
          <param argument="other_options_selector" help="See &quot;Other Options&quot; section of Help below for information" label="Do you want to tweak Other Options?" name="other_options_selector" type="select">
            <option value="yes">Yes</option>
            <option selected="true" value="no">No</option>
          </param>
          <when value="yes">
            <param argument="reorder" checked="false" falsevalue="" help="--reorder; Default=False" label="Guarantee that output SAM records are printed in an order corresponding to the order of the reads in the original input file" name="reorder" truevalue="--reorder" type="boolean"/>
            <param argument="seed" help="--seed; Default=0" label="Use this number as the seed for pseudo-random number generator" min="0" name="seed" type="integer" value="0"/>
            <param argument="non_deterministic" checked="false" falsevalue="" help="--non-deterministic; see Help below for explanation of this option; default=False" label="Re-initialize the pseudo-random generator for each read using the current time" name="non_deterministic" truevalue="--non-deterministic" type="boolean"/>
          </when>
          <when value="no"/>
        </conditional>
        <param argument="sam_opt" checked="false" falsevalue="false" help="By default, the output from this Bowtie2 wrapper is a sorted BAM file." label="Would you like the output to be a SAM file" name="sam_opt" truevalue="true" type="boolean"/>
      </when>
    </conditional>
    <param argument="save_mapping_stats" checked="False" label="Save the bowtie2 mapping statistics to the history" name="save_mapping_stats" type="boolean" truevalue="save_mapping_stats" falsevalue=""/>
  </inputs>
  <outputs>
    <data format="fastqsanger" hidden="false" label="${tool.name} on ${on_string}: unaligned reads (L)" name="output_unaligned_reads_l">
      <filter>library['unaligned_file'] is True</filter>
    </data>
    <data format="fastqsanger" hidden="false" label="${tool.name} on ${on_string}: aligned reads (L)" name="output_aligned_reads_l">
      <filter>library['aligned_file'] is True</filter>
    </data>
    <data format="fastqsanger" hidden="false" label="${tool.name} on ${on_string}: aligned reads (R)" name="output_aligned_reads_r">
      <filter>( library['type'] == "paired" or library['type'] == "paired_collection" ) and library['aligned_file'] is True</filter>
    </data>
    <data format="fastqsanger" hidden="false" label="${tool.name} on ${on_string}: unaligned reads (R)" name="output_unaligned_reads_r">
      <filter>( library['type'] == "paired" or library['type'] == "paired_collection" ) and library['unaligned_file'] is True</filter>
    </data>
    <data format="bam" hidden="false" label="${tool.name} on ${on_string}: aligned reads (sorted BAM)" name="output">
      <filter>analysis_type['analysis_type_selector'] == "simple" or analysis_type['sam_opt'] is False</filter>
    </data>
    <data format="sam" hidden="false" label="${tool.name} on ${on_string}: aligned reads (SAM)" name="output_sam">
      <filter>analysis_type['analysis_type_selector'] == "full" and analysis_type['sam_opt'] is True</filter>
    </data>
    <data format="txt" hidden="false" label="${tool.name} on ${on_string}: mapping stats" name="mapping_stats">
      <filter>save_mapping_stats is True</filter>
    </data>
  </outputs>
  <tests>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger" name="input_1" value="bowtie2-fq1.fq"/>
      <param ftype="fastqsanger" name="input_2" value="bowtie2-fq2.fq"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test1.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="rg_selector" value="set"/>
      <param name="ID" value="rg1"/>
      <param name="PL" value="CAPILLARY"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger" name="input_1" value="bowtie2-fq1.fq"/>
      <param ftype="fastqsanger" name="input_2" value="bowtie2-fq2.fq"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test2.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger" name="input_1" value="bowtie2-fq1.fq"/>
      <param ftype="fastqsanger" name="input_2" value="bowtie2-fq2.fq"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <param name="save_mapping_stats" value="true"/>
      <output file="bowtie2-test1.bam" ftype="bam" lines_diff="2" name="output"/>
      <output name="mapping_stats"/>
    </test>
    <test>
      <param name="type" value="paired_interleaved"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="rg_selector" value="set"/>
      <param name="ID" value="rg1"/>
      <param name="PL" value="CAPILLARY"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger" name="input_1" value="bowtie2-fq_il.fq"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test_il.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger.gz" name="input_1" value="bowtie2-fq1.fq.gz"/>
      <param ftype="fastqsanger.gz" name="input_2" value="bowtie2-fq2.fq.gz"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test1.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="source" value="history"/>
      <param ftype="fastqsanger.bz2" name="input_1" value="bowtie2-fq1.fq.bz2"/>
      <param ftype="fastqsanger.bz2" name="input_2" value="bowtie2-fq2.fq.bz2"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test1.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
    <test>
      <param name="type" value="paired"/>
      <param name="paired_options_selector" value="no"/>
      <param name="unaligned_file" value="false"/>
      <param name="analysis_type_selector" value="simple"/>
      <param name="source" value="history"/>
      <param ftype="fasta" name="input_1" value="bowtie2-fq1.fa"/>
      <param ftype="fasta" name="input_2" value="bowtie2-fq2.fa"/>
      <param name="own_file" value="bowtie2-ref.fasta"/>
      <output file="bowtie2-test_fasta_in.bam" ftype="bam" lines_diff="2" name="output"/>
    </test>
  </tests>
  <help><![CDATA[

**Bowtie2 Overview**

Bowtie2_ is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 supports gapped, local, and paired-end alignment modes. Galaxy wrapper for Bowtie 2 outputs alignments in `BAM format`_, enabling interoperation with a large number of other tools available at this site.
Majority of information in this page is derived from an excellent `Bowtie2 manual`_ written by Ben Langmead.

.. _Bowtie2: http://bowtie-bio.sourceforge.net/bowtie2/
.. _`Bowtie2 manual`: http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml
.. _`BAM format`: http://samtools.github.io/hts-specs/SAMv1.pdf

-----

**Selecting reference genomes for Bowtie2**

Galaxy wrapper for Bowtie2 allows you select between precomputed and user-defined indices for reference genomes using **Will you select a reference genome from your history or use a built-in index?** flag. This flag has two options:

    1. **Use a built-in genome index** - when selected (this is default), Galaxy provides the user with **Select reference genome index** dropdown. Genomes listed in this dropdown have been pre-indexed with bowtie2-build utility and are ready to be mapped against.
    2. **Use a genome from the history and build index** - when selected, Galaxy provides the user with **Select reference genome sequence** dropdown. This dropdown is populated by all FASTA formatted files listed in your current history. If your genome of interest is uploaded into history it will be shown there. Selecting a genome from this dropdown will cause Galaxy to first transparently index it using bowtie2-build command, and then run mapping with bowtie2.

If your genome of interest is not listed here you have two choices:

    1. Contact galaxy team using **Help->Support** link at the top of the interface and let us know that an index needs to be added
    2. Upload your genome of interest as a FASTA file to Galaxy history and selected **Use a genome from the history and build index** option.

------

.. class:: infomark

**Bowtie2 options**

Galaxy wrapper for Bowtie2 implements most but not all options available through the command line. Supported options are described below.

-----

**Inputs**

Bowtie 2 accepts files in Sanger FASTQ format (single or paired-end). Paired-end data can represented as two individual (forward and reverse) datasets, as well as a single interleaved dataset (see an example at the end of the help section).

------

**Input options**::

    --interleaved
            Reads interleaved FASTQ files where the first two records (8 lines) represent a mate pair.

    -s/--skip <int>
            Skip (i.e. do not align) the first `<int>` reads or pairs in the input.

    -u/--qupto <int>
            Align the first `<int>` reads or read pairs from the input (after the
            `-s`/`--skip` reads or pairs have been skipped), then stop.  Default: no limit.

    -5/--trim5 <int>
            Trim `<int>` bases from 5' (left) end of each read before alignment (default: 0).

    -3/--trim3 <int>
            Trim `<int>` bases from 3' (right) end of each read before alignment (default: 0).

    --phred33
            Input qualities are ASCII chars equal to the Phred quality plus 33.  This is
            also called the "Phred+33" encoding, which is used by the very latest Illumina
            pipelines.

    --phred64
            Input qualities are ASCII chars equal to the Phred quality plus 64.  This is
            also called the "Phred+64" encoding.

    --solexa-quals
            Convert input qualities from Solexa Phred quality (which can be negative) to
            Phred Phred quality (which can't).  This scheme was used in older Illumina GA
            Pipeline versions (prior to 1.3).  Default: off.

    --int-quals
            Quality values are represented in the read input file as space-separated ASCII integers, e.g., `40 40 30 40`..., rather than ASCII characters, e.g., `II?I`....
            Integers are treated as being on the Phred quality scale unless
            `--solexa-quals` is also specified. Default: off.

------

**Presets in `--end-to-end` mode**::

    --very-fast
            Same as: `-D 5 -R 1 -N 0 -L 22 -i S,0,2.50`

    --fast
            Same as: `-D 10 -R 2 -N 0 -L 22 -i S,0,2.50`

    --sensitive
            Same as: `-D 15 -R 2 -L 22 -i S,1,1.15` (default in `--end-to-end` mode)

    --very-sensitive
            Same as: `-D 20 -R 3 -N 0 -L 20 -i S,1,0.50`

------

**Presets options in `--local` mode**::

    --very-fast-local
            Same as: `-D 5 -R 1 -N 0 -L 25 -i S,1,2.00`

    --fast-local
            Same as: `-D 10 -R 2 -N 0 -L 22 -i S,1,1.75`

    --sensitive-local
            Same as: `-D 15 -R 2 -N 0 -L 20 -i S,1,0.75` (default in `--local` mode)

    --very-sensitive-local
            Same as: `-D 20 -R 3 -N 0 -L 20 -i S,1,0.50`

------

**Alignment options**::

    -N <int>
            Sets the number of mismatches to allowed in a seed alignment during multiseed
            alignment.  Can be set to 0 or 1. Setting this higher makes alignment slower
            (often much slower) but increases sensitivity.  Default: 0.

    -L <int>
            Sets the length of the seed substrings to align during multiseed alignment.
            Smaller values make alignment slower but more sensitive. Default: the
            `--sensitive` preset is used by default, which sets `-L` to 22 in
            `--end-to-end` mode and to 20 in `--local` mode.

    -i <func>
            Sets a function governing the interval between seed substrings to use during
            multiseed alignment.  For instance, if the read has 30 characers, and seed
            length is 10, and the seed interval is 6, the seeds extracted will be:

    Read:      TAGCTACGCTCTACGCTATCATGCATAAAC
    Seed 1 fw: TAGCTACGCT
    Seed 1 rc: AGCGTAGCTA
    Seed 2 fw:       CGCTCTACGC
    Seed 2 rc:       GCGTAGAGCG
    Seed 3 fw:             ACGCTATCAT
    Seed 3 rc:             ATGATAGCGT
    Seed 4 fw:                   TCATGCATAA
    Seed 4 rc:                   TTATGCATGA

    Since it's best to use longer intervals for longer reads, this parameter sets
    the interval as a function of the read length, rather than a single
    one-size-fits-all number.  For instance, specifying `-i S,1,2.5` sets the
    interval function `f` to `f(x) = 1 + 2.5 * sqrt(x)`, where x is the read length.
    If the function returns a result less than
    1, it is rounded up to 1. Default: the `--sensitive` preset is used by
    default, which sets `-i` to `S,1,1.15` in `--end-to-end` mode to `-i S,1,0.75`
    in `--local` mode.

    --n-ceil <func>
            Sets a function governing the maximum number of ambiguous characters (usually
            `N`s and/or `.`s) allowed in a read as a function of read length.  For instance,
            specifying `-L,0,0.15` sets the N-ceiling function `f` to `f(x) = 0 + 0.15 * x`,
            where x is the read length.  Reads exceeding this ceiling are filtered out.
            Default: `L,0,0.15`.

    --dpad <int>
            "Pads" dynamic programming problems by `<int>` columns on either side to allow
            gaps.  Default: 15.

    --gbar <int>
            Disallow gaps within `<int>` positions of the beginning or end of the read.
            Default: 4.

    --ignore-quals
            When calculating a mismatch penalty, always consider the quality value at the
            mismatched position to be the highest possible, regardless of the actual value.
            I.e. input is treated as though all quality values are high.  This is also the
            default behavior when the input doesn't specify quality values (e.g. in `-f`,
            `-r`, or `-c` modes).

    --nofw/--norc
            If `--nofw` is specified, `bowtie2` will not attempt to align unpaired reads to
            the forward (Watson) reference strand.  If `--norc` is specified, `bowtie2` will
            not attempt to align unpaired reads against the reverse-complement (Crick)
            reference strand. In paired-end mode, `--nofw` and `--norc` pertain to the
            fragments; i.e. specifying `--nofw` causes `bowtie2` to explore only those
            paired-end configurations corresponding to fragments from the reverse-complement
            (Crick) strand.  Default: both strands enabled.

    --no-1mm-upfront
            By default, Bowtie 2 will attempt to find either an exact or a 1-mismatch
            end-to-end alignment for the read *before* trying the multiseed heuristic.  Such
            alignments can be found very quickly, and many short read alignments have exact or
            near-exact end-to-end alignments.  However, this can lead to unexpected
            alignments when the user also sets options governing the multiseed heuristic,
            like `-L` and `-N`.  For instance, if the user specifies `-N 0` and `-L` equal
            to the length of the read, the user will be surprised to find 1-mismatch alignments
            reported.  This option prevents Bowtie 2 from searching for 1-mismatch end-to-end
            alignments before using the multiseed heuristic, which leads to the expected
            behavior when combined with options such as `-L` and `-N`.  This comes at the
            expense of speed.

    --end-to-end
            In this mode, Bowtie 2 requires that the entire read align from one end to the
            other, without any trimming (or "soft clipping") of characters from either end.
            The match bonus `--ma` always equals 0 in this mode, so all alignment scores
            are less than or equal to 0, and the greatest possible alignment score is 0.
            This is mutually exclusive with `--local`.  `--end-to-end` is the default mode.

    --local
            In this mode, Bowtie 2 does not require that the entire read align from one end
            to the other.  Rather, some characters may be omitted ("soft clipped") from the
            ends in order to achieve the greatest possible alignment score.  The match bonus
            `--ma` is used in this mode, and the best possible alignment score is equal to
            the match bonus (`--ma`) times the length of the read.  Specifying `--local`
            and one of the presets (e.g. `--local --very-fast`) is equivalent to specifying
            the local version of the preset (`--very-fast-local`).  This is mutually
            exclusive with `--end-to-end`.  `--end-to-end` is the default mode.

-----

**Scoring options**::

    --ma <int>
            Sets the match bonus.  In `--local` mode `<int>` is added to the alignment
            score for each position where a read character aligns to a reference character
            and the characters match.  Not used in `--end-to-end` mode.  Default: 2.

    --mp MX,MN
            Sets the maximum (`MX`) and minimum (`MN`) mismatch penalties, both integers.  A
            number less than or equal to `MX` and greater than or equal to `MN` is
            subtracted from the alignment score for each position where a read character
            aligns to a reference character, the characters do not match, and neither is an
            `N`.  If `--ignore-quals` is specified, the number subtracted quals `MX`.
            Otherwise, the number subtracted is `MN + floor( (MX-MN)(MIN(Q, 40.0)/40.0) )`
            where Q is the Phred quality value.  Default: `MX` = 6, `MN` = 2.

    --np <int>
            Sets penalty for positions where the read, reference, or both, contain an
            ambiguous character such as `N`.  Default: 1.

    --rdg <int1>,<int2>
            Sets the read gap open (`<int1>`) and extend (`<int2>`) penalties.  A read gap of
            length N gets a penalty of `<int1>` + N * `<int2>`.  Default: 5, 3.

    --rfg <int1>,<int2>
            Sets the reference gap open (`<int1>`) and extend (`<int2>`) penalties.  A
            reference gap of length N gets a penalty of `<int1>` + N * `<int2>`.  Default:
            5, 3.

    --score-min <func>
            Sets a function governing the minimum alignment score needed for an alignment to
            be considered "valid" (i.e. good enough to report).  This is a function of read
            length. For instance, specifying `L,0,-0.6` sets the minimum-score function `f`
            to `f(x) = 0 + -0.6 * x`, where `x` is the read length.  The default in `--end-to-end` mode is `L,-0.6,-0.6` and
            the default in `--local` mode is `G,20,8`.

-----

**Reporting options**::

    -k <int>
            By default, `bowtie2` searches for distinct, valid alignments for each read.
            When it finds a valid alignment, it continues looking for alignments that are
            nearly as good or better.  The best alignment found is reported (randomly
            selected from among best if tied).  Information about the best alignments is
            used to estimate mapping quality and to set SAM optional fields, such as
            `AS:i` and `XS:i`.

    When `-k` is specified, however, `bowtie2` behaves differently.  Instead, it
    searches for at most `<int>` distinct, valid alignments for each read.  The
    search terminates when it can't find more distinct valid alignments, or when it
    finds `<int>`, whichever happens first.  All alignments found are reported in
    descending order by alignment score. The alignment score for a paired-end
    alignment equals the sum of the alignment scores of the individual mates. Each
    reported read or pair alignment beyond the first has the SAM 'secondary' bit
    (which equals 256) set in its FLAGS field.  For reads that have more than
    `<int>` distinct, valid alignments, `bowtie2` does not guarantee that the
    `<int>` alignments reported are the best possible in terms of alignment score.
    `-k` is mutually exclusive with `-a`.

    Note: Bowtie 2 is not designed with large values for `-k` in mind, and when
    aligning reads to long, repetitive genomes large `-k` can be very, very slow.

    -a
            Like `-k` but with no upper limit on number of alignments to search for.  `-a`
            is mutually exclusive with `-k`.

    Note: Bowtie 2 is not designed with `-a` mode in mind, and when
    aligning reads to long, repetitive genomes this mode can be very, very slow.

-----

**Effort options**::

    -D <int>
            Up to `<int>` consecutive seed extension attempts can "fail" before Bowtie 2
            moves on, using the alignments found so far.  A seed extension "fails" if it
            does not yield a new best or a new second-best alignment.  This limit is
            automatically adjusted up when -k or -a are specified.  Default: 15.

    -R <int>
            `<int>` is the maximum number of times Bowtie 2 will "re-seed" reads with
            repetitive seeds. When "re-seeding," Bowtie 2 simply chooses a new set of reads
            (same length, same number of mismatches allowed) at different offsets and
            searches for more alignments.  A read is considered to have repetitive seeds if
            the total number of seed hits divided by the number of seeds that aligned at
            least once is greater than 300.  Default: 2.

-----

**Paired-end options**::

    -I/--minins <int>
            The minimum fragment length for valid paired-end alignments.  E.g. if `-I 60` is
            specified and a paired-end alignment consists of two 20-bp alignments in the
            appropriate orientation with a 20-bp gap between them, that alignment is
            considered valid (as long as `-X` is also satisfied).  A 19-bp gap would not
            be valid in that case.  If trimming options `-3` or `-5` are also used, the
            `-I` constraint is applied with respect to the untrimmed mates.

            The larger the difference between `-I` and `-X`, the slower Bowtie 2 will
            run.  This is because larger differences bewteen `-I` and `-X` require that
            Bowtie 2 scan a larger window to determine if a concordant alignment exists.
            For typical fragment length ranges (200 to 400 nucleotides), Bowtie 2 is very
            efficient.

            Default: 0 (essentially imposing no minimum)

    -X/--maxins <int>
            The maximum fragment length for valid paired-end alignments.  E.g. if `-X 100`
            is specified and a paired-end alignment consists of two 20-bp alignments in the
            proper orientation with a 60-bp gap between them, that alignment is considered
            valid (as long as `-I` is also satisfied).  A 61-bp gap would not be valid in
            that case.  If trimming options `-3` or `-5` are also used, the `-X`
            constraint is applied with respect to the untrimmed mates, not the trimmed
            mates.

            The larger the difference between `-I` and `-X`, the slower Bowtie 2 will
            run.  This is because larger differences bewteen `-I` and `-X` require that
            Bowtie 2 scan a larger window to determine if a concordant alignment exists.
            For typical fragment length ranges (200 to 400 nucleotides), Bowtie 2 is very
            efficient.

            Default: 500.

    --fr/--rf/--ff
            The upstream/downstream mate orientations for a valid paired-end alignment
            against the forward reference strand.  E.g., if `--fr` is specified and there is
            a candidate paired-end alignment where mate 1 appears upstream of the reverse
            complement of mate 2 and the fragment length constraints (`-I` and `-X`) are
            met, that alignment is valid.  Also, if mate 2 appears upstream of the reverse
            complement of mate 1 and all other constraints are met, that too is valid.
            `--rf` likewise requires that an upstream mate1 be reverse-complemented and a
            downstream mate2 be forward-oriented. ` --ff` requires both an upstream mate 1
            and a downstream mate 2 to be forward-oriented.  Default: `--fr` (appropriate
            for Illumina's Paired-end Sequencing Assay).

    --no-mixed
            By default, when `bowtie2` cannot find a concordant or discordant alignment for
            a pair, it then tries to find alignments for the individual mates.  This option
            disables that behavior.

    --no-discordant
            By default, `bowtie2` looks for discordant alignments if it cannot find any
            concordant alignments.  A discordant alignment is an alignment where both mates
            align uniquely, but that does not satisfy the paired-end constraints
            (`--fr`/`--rf`/`--ff`, `-I`, `-X`).  This option disables that behavior.

    --dovetail
            If the mates "dovetail", that is if one mate alignment extends past the
            beginning of the other such that the wrong mate begins upstream, consider that
            to be concordant.  Default: mates cannot dovetail in a concordant alignment.

    --no-contain
            If one mate alignment contains the other, consider that to be non-concordant.
            Default: a mate can contain the other in a concordant alignment.

    --no-overlap
            If one mate alignment overlaps the other at all, consider that to be
            non-concordant.  Default: mates can overlap in a concordant alignment.

------

**SAM options**::

    --rg-id <text>
            Set the read group ID to `<text>`.  This causes the SAM `@RG` header line to be
            printed, with `<text>` as the value associated with the `ID:` tag.  It also
            causes the `RG:Z:` extra field to be attached to each SAM output record, with
            value set to `<text>`.

    --rg <text>
            Add `<text>` (usually of the form `TAG:VAL`, e.g. `SM:Pool1`) as a field on the
            `@RG` header line.  Note: in order for the `@RG` line to appear, `--rg-id`
            must also be specified.  This is because the `ID` tag is required by the SAM
            Specification.  Specify `--rg` multiple times to set multiple fields.  See the
            SAM Specification for details about what fields are legal.

    --omit-sec-seq
            When printing secondary alignments, Bowtie 2 by default will write out the `SEQ`
            and `QUAL` strings.  Specifying this option causes Bowtie 2 to print an asterix
            in those fields instead.

-----

**Other options**::

    --reorder
            Guarantees that output SAM records are printed in an order corresponding to the
            order of the reads in the original input file, even when `-p` is set greater
            than 1.  Specifying `--reorder` and setting `-p` greater than 1 causes Bowtie
            2 to run somewhat slower and use somewhat more memory then if `--reorder` were
            not specified.  Has no effect if `-p` is set to 1, since output order will
            naturally correspond to input order in that case.

    --seed <int>
            Use `<int>` as the seed for pseudo-random number generator.  Default: 0.

    --non-deterministic
            Normally, Bowtie 2 re-initializes its pseudo-random generator for each read.  It
            seeds the generator with a number derived from (a) the read name, (b) the
            nucleotide sequence, (c) the quality sequence, (d) the value of the `--seed`
            option. This means that if two reads are identical (same name, same
            nucleotides, same qualities) Bowtie 2 will find and report the same alignment(s)
            for both, even if there was ambiguity.  When `--non-deterministic` is specified,
            Bowtie 2 re-initializes its pseudo-random generator for each read using the
            current time.  This means that Bowtie 2 will not necessarily report the same
            alignment for two identical reads.  This is counter-intuitive for some users,
            but might be more appropriate in situations where the input consists of many
            identical reads.

-----


**Paired-end (and mate-pair) data in fastq format**

Paired end datasets can be represented as two individual datasets:

First dataset::

 @1/1
 AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
 +
 EGGEGGGDFGEEEAEECGDEGGFEEGEFGBEEDDECFEFDD@CDD<ED
 @2/1
 AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
 +
 HHHHHHEGFHEEFEEHEEHHGGEGGGGEFGFGGGGHHHHFBEEEEEFG

Second dataset::

 @1/2
 CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
 +
 GHHHDFDFGFGEGFBGEGGEGEGGGHGFGHFHFHHHHHHHEF?EFEFF
 @2/2
 CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
 +
 HHHHHHHHHHHHHGHHHHHHGHHHHHHHHHHHFHHHFHHHHHHHHHHH

Or a single *interleaved* dataset::

 @1/1
 AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
 +
 EGGEGGGDFGEEEAEECGDEGGFEEGEFGBEEDDECFEFDD@CDD<ED
 @1/2
 CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
 +
 GHHHDFDFGFGEGFBGEGGEGEGGGHGFGHFHFHHHHHHHEF?EFEFF
 @2/1
 AGGGATGTGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTAGGGTTA
 +
 HHHHHHEGFHEEFEEHEEHHGGEGGGGEFGFGGGGHHHHFBEEEEEFG
 @2/2
 CCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC
 +
 HHHHHHHHHHHHHGHHHHHHGHHHHHHHHHHHFHHHFHHHHHHHHHHH




    ]]></help>
  <citations>
    <citation type="doi">10.1186/gb-2009-10-3-r25</citation>
    <citation type="doi">10.1038/nmeth.1923</citation>
  </citations>
</tool>
